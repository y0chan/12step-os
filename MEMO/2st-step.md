# 2st-step
## メモリマップドI/O
- 周辺ハードウェアの制御について
    - プログラムによってソフトウェア的に周辺機器とデータのやり取りを実施できる?
        - 非常に面倒
            - CPUが他の作業をしにくくなる
    - CPUにはでなく、このような動作を行うICチップを実装して、それに行わせる
        - このような制御を行うICチップをコントローラという
    - CPUからはコントローラに対して、
        - データの送信要求を出したり
        - コントローラからデータを受信したりするだけ
- コントローラの操作方法
    - コントローラの制御はレジスタで行う
        - 特定のレジスタに1バイト書き込むと、あとはコントローラ側でその1バイトを送信するなど
- CPUにメモリ(DRAM)を増設することを考える
    - CPUのビット数
        - CPUが内部で扱うビット幅
        - 大抵データ・バスの幅と一致
            - 数値データを転送するためにCPUが持っている入出力ピンのこと
    - アドレス・バス
        - アドレスを指定するためにCPUが持っている出力ピンのこと
            - データ・バスとアドレス・バスは別
                - 32bitCPUならばそれぞれデータ・バスとアドレス・バスを32本持つ
    - 1MBのDRAMを4枚接続することを考える
        - 上位12bitの値に応じて、4つのDRAMのうちいずれかを選択するようにする
            - DRAMにはチップ・セレクトという、そのチップが動作のON/OFFを操作できるピンがあるのでそれを利用する
            - 上位12bitの値に応じて、それぞれのチップ・セレクトがONになるような回路にする
                - そのため比較器(コンバータ)という回路が必要
- シリアル・コントローラの制御
    - シリアル・コントローラ自身が制御用のレジスタを持っている
    - そのため、シリアル・コントローラもアドレス線をもっている
        - アドレスによってどのレジスタが操作されるかが決まる
        - 本書の例だと
            - CPUから0x10000000 ~ 0x1000000fというアドレスを読み書きするとシリアル・コントローラのチップ・セレクト信号がONになる
            - これをシリアル・コントローラのレジスタは0x10000000 ~ 0x1000000fにマッピングされているという
- このようにメモリだけでなく、各種コントローラのレジスタもアドレス空間上にマッピングする
    - CPUからコントローラのレジスタがアドレス上に見えるようになる
    - このようなI/O操作方法をメモリマップドI/Oと呼ぶ

## C言語でのデバイス操作
- C言語では次のようにレジスタ1を読み書きして、コントローラを操作する
- `volatile`というキーワードが重要
    - レジスタを操作するための変数を`volatile`で定義する
    - これをつけないと、コンパイルがレジスタ変数への書き込みを最適化しすぎてしまう
        - 具体例は本書を読む

```
char c;
volatile char *reg1 = (char *)0x1000000;

c = *reg1;
*reg1 = 0x01;
```

## 内蔵シリアル・コントローラ
- H8/3069Fは**SCI**と呼ばれるシリアル・コントローラを内蔵している
- SCI
    - シリアル・コントローラを3つ内蔵している
        - SCI0
        - SCI1
        - SCI2
    - SCIはCPU上に組み込まれているため、マッピングされているアドレスは決められている
- SCI1
    - シリアル経由の入出力が行える
    - SCI1の各レジスタの説明は本書P.65を参照

- **以下SCI1を弄くり、シリアル通信を行うことを目的とする**
- シリアル送信のパラメータ
    - SMR
        - シリアル通信のモード設定
        - **全部0**に設定する
    - SCR
        - 送受信の有効/無効
- シリアルの転送速度(ボーレート)の指定
    - BRR
        - ボーレートの設定
- 文字の送信
    - TDR
        - 送信したい1文字を書き込む
    - SSR
        - 送信完了/受信完了などを表す
- `serial_init()`で初期化している
### モードレジスタの設定(SMR)
- SMR
    - シリアルモードレジスタ
    - シリアル入出力のパラメータ設定を行う
- 全部0に設定する

### コントロールレジスタの設定(SCR)
- SCR
    - シリアルコントローラレジスタ
    - 送受信の有効/無効の切替え
    - 割り込みの有効/無効の切替え
- コントローラのモード設定はそのコントローラを無効化した状態で行い、設定完了した最後に有効化する
- `serial_init()`では
    - SCRにゼロを設定し、シリアル送受信と割込みをすべて無効化
    - SMRとBRRの設定をした後、SCRの受信イネーブルと送信イネーブルビットを立て、送受信を有効化

### BRRの設定
- BRR
    - ビットレートレジスタ
    - シリアル通信の速度(ボーレート)の設定
    - シリアル通信のボーレートは9600bpsが一般的
    - そうなるようパラメータを設定

### シリアルの文字出力
- SCI1では1文字出力を行うのに以下のレジスタを使用
    - TDR
        - トランスミットデータレジスタ
        - 送信したい1文字を書き込む
    - SSR
        - シリアルステータスレジスタ
        - 送信完了/受信完了などを表す
- 1文字の送信手順
    - SSRの送信完了ビットが落ちていないことを確認
        - `serial_is_send_enable`で送信完了ビットをみる
        - 以下`serial_send_byte`のwhile文
    - TDRに送信した文字を書き込む
    - SSRの送信完了ビットを落とす
    - 送信が完了すると、コントローラがSSRの送信完了ビットを立てる

### 端末変換
- 実際に呼び出しているのは`puts()`という関数
    - `puts()`から`putc()`を呼び出している
        - `putc()`から`serial_is_send_enable()`を呼び出す
- C言語では改行コードは`\n`
- シリアル端末では`\r`が利用される
- さらにPC側からシリアル出力する場合には、改行コードは`\n`から`\r\n`のように変換する
    - これを端末変換という

## ライブラリ関数の追加
- **H8は16ビットCPU**であるため、int型は16ビット
